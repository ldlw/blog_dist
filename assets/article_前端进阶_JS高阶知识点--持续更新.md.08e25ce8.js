import{_ as s,c as n,o as a,a as l}from"./app.2ff528bf.js";const F=JSON.parse('{"title":"JS 高阶知识点 -- 持续更新","description":"高阶知识点","frontmatter":{"head":[["meta",{"name":"description","content":"高阶知识点"}],["meta",{"name":"keywords","content":"JS"}],["script",{"src":"https://vitepress-source.oss-cn-beijing.aliyuncs.com/statistics.js"}]]},"headers":[{"level":2,"title":"DOM 元素节点的类型","slug":"dom-元素节点的类型","link":"#dom-元素节点的类型","children":[]},{"level":2,"title":"数组的 splice 与 slice 的区别","slug":"数组的-splice-与-slice-的区别","link":"#数组的-splice-与-slice-的区别","children":[]},{"level":2,"title":"substr 和 substring 的区别？","slug":"substr-和-substring-的区别","link":"#substr-和-substring-的区别","children":[]},{"level":2,"title":"JS 延迟加载的方法有哪些？","slug":"js-延迟加载的方法有哪些","link":"#js-延迟加载的方法有哪些","children":[]},{"level":2,"title":"异步脚本 defer 和 async 的区别","slug":"异步脚本-defer-和-async-的区别","link":"#异步脚本-defer-和-async-的区别","children":[]},{"level":2,"title":"为什么 Commonjs 不适用于浏览器","slug":"为什么-commonjs-不适用于浏览器","link":"#为什么-commonjs-不适用于浏览器","children":[]},{"level":2,"title":"Commonjs 和 ES6 Module 的区别","slug":"commonjs-和-es6-module-的区别","link":"#commonjs-和-es6-module-的区别","children":[]},{"level":2,"title":"深度遍历与广度遍历的区别","slug":"深度遍历与广度遍历的区别","link":"#深度遍历与广度遍历的区别","children":[]},{"level":2,"title":"文档碎片","slug":"文档碎片","link":"#文档碎片","children":[]},{"level":2,"title":"元素进入视口 - IntersectionObserver","slug":"元素进入视口-intersectionobserver","link":"#元素进入视口-intersectionobserver","children":[]},{"level":2,"title":"大数运算（bigInt）","slug":"大数运算-bigint","link":"#大数运算-bigint","children":[]},{"level":2,"title":"数字分隔符","slug":"数字分隔符","link":"#数字分隔符","children":[]},{"level":2,"title":"Object.hasOwn","slug":"object-hasown","link":"#object-hasown","children":[]}],"relativePath":"article/前端进阶/JS高阶知识点--持续更新.md"}'),o={name:"article/前端进阶/JS高阶知识点--持续更新.md"},p=l(`<h1 id="js-高阶知识点-持续更新" tabindex="-1">JS 高阶知识点 -- 持续更新 <a class="header-anchor" href="#js-高阶知识点-持续更新" aria-hidden="true">#</a></h1><p>逛稀土掘金看到的些好文章，记录的非常的详细，JS 高阶知识点。</p><h2 id="dom-元素节点的类型" tabindex="-1">DOM 元素节点的类型 <a class="header-anchor" href="#dom-元素节点的类型" aria-hidden="true">#</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">元素节点            　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ELEMENT_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">属性节点            　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ATTRIBUTE_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">文本节点            　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">TEXT_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">CDATA节点             Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">CDATA_SECTION_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">4</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">实体引用名称节点    　　 Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ENTRY_REFERENCE_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">实体名称节点        　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ENTITY_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">6</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">处理指令节点        　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">PROCESSING_INSTRUCTION_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">7</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">注释节点            　 Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">COMMENT_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">8</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">文档节点            　 Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">DOCUMENT_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">9</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">文档类型节点        　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">DOCUMENT_TYPE_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">10</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">文档片段节点        　　Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">DOCUMENT_FRAGMENT_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">11</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">DTD声明节点            Node</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">NOTATION_NODE</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">12</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h2 id="数组的-splice-与-slice-的区别" tabindex="-1">数组的 splice 与 slice 的区别 <a class="header-anchor" href="#数组的-splice-与-slice-的区别" aria-hidden="true">#</a></h2><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>splice</td><td>splice(start, num, item1, item2, ...)</td><td>从 start 索引开始，截取 num 个元素，并插入 item1、item2 到原数组里，影响原数组</td></tr><tr><td>slice</td><td>slice(start, end)</td><td>从 start 开始，截取到 end - 1，如果没有 end，则截取到左后一个元素，不影响原数组</td></tr></tbody></table><h2 id="substr-和-substring-的区别" tabindex="-1">substr 和 substring 的区别？ <a class="header-anchor" href="#substr-和-substring-的区别" aria-hidden="true">#</a></h2><table><thead><tr><th>方法</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>substr</td><td>substr(start,length)</td><td>返回从 start 位置开始 length 长度的子串</td></tr><tr><td>substring</td><td>substring(start,end)</td><td>返回从 start 位置开始到 end 位置的子串（不包含 end）</td></tr></tbody></table><h2 id="js-延迟加载的方法有哪些" tabindex="-1">JS 延迟加载的方法有哪些？ <a class="header-anchor" href="#js-延迟加载的方法有哪些" aria-hidden="true">#</a></h2><ul><li><p><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code> ：给 script 标签加 async 属性，则加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）</p></li><li><p><code>&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</code>：给 script 标签加 defer 属性，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成</p></li><li><p>动态创建 script 标签：等到<code>DOMContentLoaded</code> 事件触发时，生成一个 script 标签，渲染到页面上上</p></li><li><p>setTimeout 定时器延迟代码执行</p></li></ul><h2 id="异步脚本-defer-和-async-的区别" tabindex="-1">异步脚本 defer 和 async 的区别 <a class="header-anchor" href="#异步脚本-defer-和-async-的区别" aria-hidden="true">#</a></h2><ul><li>当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关。</li><li>当 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析。</li></ul><p>总结：defer 脚本是异步加载，但是执行时是等整个文档结束之后执行，async 脚本也是异步加载，但是执行是异步脚本加载完成之后就执行，执行的时候文档停止解析，等到脚本执行结束之后继续文档解析</p><h2 id="为什么-commonjs-不适用于浏览器" tabindex="-1">为什么 Commonjs 不适用于浏览器 <a class="header-anchor" href="#为什么-commonjs-不适用于浏览器" aria-hidden="true">#</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> math </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">math</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>第二行 math.add(2, 3)，在第一行 require(&#39;math&#39;)之后运行，因此必须等 math.js 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p><p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于&quot;假死&quot;状态。</p><p>因此，浏览器端的模块，不能采用&quot;同步加载&quot;（synchronous），只能采用&quot;异步加载&quot;（asynchronous）。这就是 AMD 规范诞生的背景。</p><h2 id="commonjs-和-es6-module-的区别" tabindex="-1">Commonjs 和 ES6 Module 的区别 <a class="header-anchor" href="#commonjs-和-es6-module-的区别" aria-hidden="true">#</a></h2><ul><li>Commonjs 是拷贝输出，ES6 模块化是引用输出（更快，更适合浏览器）</li><li>Commonjs 是运行时加载，ES6 模块化是编译时输出接口</li><li>Commonjs 是单个值导出，ES6 模块化可以多个值导出</li><li>Commonjs 是动态语法可写在函数体中，ES6 模块化静态语法只能写在顶层</li><li>Commonjs 的 this 是当前模块化，ES6 模块化的 this 是 undefined</li></ul><h2 id="深度遍历与广度遍历的区别" tabindex="-1">深度遍历与广度遍历的区别 <a class="header-anchor" href="#深度遍历与广度遍历的区别" aria-hidden="true">#</a></h2><ul><li>深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大</li><li>深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点</li><li>深度优先采用的是堆栈的形式 即先进后出</li><li>广度优先则采用的是队列的形式 即先进先出</li></ul><h2 id="文档碎片" tabindex="-1">文档碎片 <a class="header-anchor" href="#文档碎片" aria-hidden="true">#</a></h2><ul><li>是什么：一个容器，用于暂时存放创建的 dom 元素，使用<code>document.createDocumentFragment()</code>创建</li><li>有什么用：将需要添加的大量元素 先添加到文档碎片 中，再将文档碎片添加到需要插入的位置，大大减少 dom 操作，提高性能</li></ul><p>Jxue.js 吸收了这一点，当需要编译大段文本的时候，这个是个杀招！</p><h2 id="元素进入视口-intersectionobserver" tabindex="-1">元素进入视口 - IntersectionObserver <a class="header-anchor" href="#元素进入视口-intersectionobserver" aria-hidden="true">#</a></h2><p>案例：很长的页面底部有一个评论区，当出现评论区时需要显示评论区的回复框。</p><p>方案 1：大多数同学心里想的是不是和我一样需要计算页面的高度，当达到指定的高度时显示？</p><p>不足之处：这样其实是不好的，当页面是个多路由每个路由下都有评论区，且页面高度都不同的情况呢？每次都要计算？加上我们必须监听滚动条的滚动事件，由于滚动事件机密发生，就算加上防抖，计算量也很大，容器造成性能问题！！</p><p>方案 2：<strong>IntersectionObserver API</strong></p><blockquote><p>它的优点是不会引起重绘回流</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> div2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> observer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">IntersectionObserver</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">entries</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">entries</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">element</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">index</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">element</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">element</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">isIntersecting</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">				</span><span style="color:#676E95;font-style:italic;">// element.isIntersecting 表示可见</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#A6ACCD;">div1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerText</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">我出来了</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#A6ACCD;">div1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerText</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">首页</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">		</span><span style="color:#F07178;">root</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line"><span style="color:#A6ACCD;">		</span><span style="color:#F07178;">threshold</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">observe</span><span style="color:#A6ACCD;">(div2) </span><span style="color:#676E95;font-style:italic;">// 监听 div2</span></span>
<span class="line"></span></code></pre></div><p>callback 函数的参数（entries）是一个数组，每个成员都是一个 IntersectionObserverEntry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。</p><ul><li><p>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</p></li><li><p>target：被观察的目标元素，是一个 DOM 节点对象</p></li><li><p>isIntersecting: 目标是否可见</p></li><li><p>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null</p></li><li><p>boundingClientRect：目标元素的矩形区域的信息</p></li><li><p>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</p></li><li><p>intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，</p></li></ul><h2 id="大数运算-bigint" tabindex="-1">大数运算（bigInt） <a class="header-anchor" href="#大数运算-bigint" aria-hidden="true">#</a></h2><p>JS 在正常情况下表示整数是有范围的，当超过最大值的时候就会触发精度问题。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pow</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">53</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pow</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">53</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Math.pow(2, 53) =&gt; 9007199254740992</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Math.pow(2, 53) + 1 =&gt; 9007199254740992</span></span>
<span class="line"></span></code></pre></div><p>在上面的例子中，最多只能表示 9007199254740992 在这个基础上再加也没用。相信总会有计算特别大的数的需求，所以这时候我们就可以使用 <code>BigInt</code> 函数来处理。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">BigInt</span><span style="color:#A6ACCD;">(Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pow</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">53</span><span style="color:#A6ACCD;">)) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BigInt</span><span style="color:#A6ACCD;">(Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pow</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">53</span><span style="color:#A6ACCD;">)) </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BigInt</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">BigInt</span><span style="color:#A6ACCD;">(Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pow</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">53</span><span style="color:#A6ACCD;">)) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BigInt</span><span style="color:#A6ACCD;">(Math</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pow</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">53</span><span style="color:#A6ACCD;">)) </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 报错 BigInt类型只能与BigInt类型相加  否则会有类型错误</span></span>
<span class="line"></span></code></pre></div><h2 id="数字分隔符" tabindex="-1">数字分隔符 <a class="header-anchor" href="#数字分隔符" aria-hidden="true">#</a></h2><p>又是一个为和大数值打交道而产生的一个新的写法，让人眼前一亮！</p><p>在过去，如果我们要表示 100W，写法为 1000000</p><p>使用数字分隔符之后：</p><p>1_000_000</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">1000000</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1_000_000</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div><p><img src="https://vitepress-source.oss-cn-beijing.aliyuncs.com/typoraimage-20220506205812813.png" alt="image-20220506205812813"></p><h2 id="object-hasown" tabindex="-1">Object.hasOwn <a class="header-anchor" href="#object-hasown" aria-hidden="true">#</a></h2><p>这是一个比较新的 API，其要实现的目的和<code>in</code>、<code>Object.hasOwnProperty</code>是一样的，都是判断对象上是否存在于某个属性，区别在于，<code>Object.hasOwn</code>是目前为止最安全的一个 API！</p><ul><li><p><code>in</code> 操作符，会触发原型链的查找，这个容易出问题，也不够稳健，不推荐使用</p></li><li><p><code>Object.hasOwnProperty</code> 只会在当前的对象上查找，不会触发原型链的查找，相对稳健，但是在特殊的情况下也是会报错的。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">name</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// v报错</span></span>
<span class="line"></span></code></pre></div></li><li><p><code>Object.hasOwn</code> 最推荐的一种 API，是上一种的升级版本，更适合于生产环境下，非常的稳健和靠谱</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> object </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">24</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwn</span><span style="color:#A6ACCD;">(object</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">age</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> object2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">24</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwn</span><span style="color:#A6ACCD;">(object2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">age</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> object3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwn</span><span style="color:#A6ACCD;">(object3</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">age</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"></span></code></pre></div></li></ul>`,49),e=[p];function t(c,r,i,y,C,D){return a(),n("div",null,e)}const d=s(o,[["render",t]]);export{F as __pageData,d as default};
